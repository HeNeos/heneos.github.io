---
layout: post
title: Project Euler 625
subtitle: Gcd sum
gh-repo: HeNeos/heneos.github.io
gh-badge: [star, follow]
comments: true
tags: [Project Euler]
---

I was reading a lot of stuff about Dirichlet Convolution and how to solve sums over arithmetic functions. There are a lot of resources and I don't consider that it's an easy topic. Even when I don't use Dirichlet here, It's something that I'll try to practice more because it's really useful when you're working with Mobius function. Maybe I need to review my past codes to see if I can improve them.

## Statement

\begin{aligned}
    G(N) = \sum_{j=1}^{N} \sum_{i=1}^{j} \gcd(i, j)
\end{aligned}

Find $G(10^{11})$. Give your answer modulo 998244353.

## Solution

First, I'll calculate the sum of $\gcd(i, n)$:

\begin{aligned}
    g(n) &= \sum_{i=1}^{n} \gcd(i, n)\cr
    &= \sum_{k\vert n} k \phi\Big( \frac{n}{k} \Big)\cr
    &= (n * \phi)(n)
\end{aligned}

The last line is the dirichlet notation, it could be useful.

Now, we can use $g(n)$ to calculate $G(N)$:

\begin{aligned}
    G(N) &= \sum_{i=1}^{N} g(i)\cr
    &= \sum_{i=1}^{N} \sum_{k \vert i} \phi(k) \frac{i}{k}\cr
    &= \sum_{k=1}^{N} \sum_{p=1}^{\frac{N}{k}} \phi(k) p\cr
    &= \sum_{k=1}^{N} \sum_{p=1}^{\frac{N}{k}} \phi(k) p\cr
    &= \sum_{k=1}^{N} \phi(k) \frac{\frac{N}{k}(\frac{N}{k} + 1)}{2}\cr
\end{aligned}

As you can see, we want to calculate sums of $\phi(k)$, so let's to reduce it:

\begin{aligned}
    S(n) &= \sum_{i=1}^{n} \phi(i) \cr
    &= \sum_{b=1}^{n} \sum_{a=1}^{b} \big\vert \gcd(a, b) = 1 \big\vert \cr
    &= \frac{n(n+1)}{2} - \sum_{m=2}^{n} \sum_{y=1}^{\lfloor n/m \rfloor} \sum_{x=1}^{\lfloor b/m \rfloor} \big\vert \gcd(x, y) = 1 \big\vert \cr
    &= \frac{n(n+1)}{2} - \sum_{m=2}^{n} S(\lfloor n/m \rfloor) \cr
    &= \frac{n(n+1)}{2} - \sum_{m=2}^{\sqrt{n}} S(\lfloor n/m \rfloor) - \sum_{m=1}^{\lfloor \frac{n}{\lfloor \sqrt{n} \rfloor} \rfloor - 1} \Big(\Big\lfloor\frac{n}{m} \Big\rfloor - \Big\lfloor\frac{n}{m+1} \Big\rfloor \Big) S(m)\cr
    S(n) &= \Phi(n)
\end{aligned}

This is a recursive definition. It's not hard to see that the time complexity for this is $O(n^{2/3})$.

Similar to the explained in a [previous post](https://heneos.github.io/2023-03-26-spoj-gcdex/), the list of possible values of $\lfloor N/k \rfloor$ has a size of $2\sqrt{N}$. I will use the hyperbola method to calculate it:

\begin{aligned}
    G(N) &= \sum_{k=1}^{N} \phi(k) \frac{\frac{N}{k}(\frac{N}{k} + 1)}{2}\cr
    &= \sum_{k=1}^{N} \phi(k) \sum_{ab=k} a \phi(b) \cr
    &= \sum_{a=1}^{\sqrt{N}} \sum_{b=1}^{N/a} a\phi(b) + \sum_{b=1}^{\sqrt{N}} \sum_{a=1}^{N/b} a\phi(b) - \sum_{a=1}^{\sqrt{N}} \sum_{b=1}^{\sqrt{N}} a\phi(b)\cr
    &= \sum_{a=1}^{\sqrt{N}} a \Phi(\lfloor N/a \rfloor) + \sum_{b=1}^{\lfloor \sqrt{N} \rfloor} \phi(b) \frac{\lfloor N/b\rfloor \times (\lfloor N/b\rfloor + 1)}{2} - \frac{\lfloor \sqrt{N}\rfloor (\lfloor \sqrt{N} \rfloor + 1)}{2}\Phi(\lfloor \sqrt{N} \rfloor)\cr
\end{aligned}

To optimize the complexity, suppose that we will do a sieve until $N/k$, so the overall complexity will be:

\begin{aligned}
    O(G(N)) &= O(\sum_{a=1}^{k} O(\Phi(\lfloor N/a\rfloor))) + O(\sqrt{N}) + O(N/k \log(N/k))\cr
    &= O(\sum_{a=1}^{k} 1) + O(N^{2/3}) + O(N/k \log(N/k))\cr
    &= O(k) + O(N^{2/3}) + O(N/k \log(N/k))\cr
    &\text{Optimal value is when:}\cr
    & N^{2/3} + k = N/k \log(N/k)\cr
    & k \approx \sqrt{N/2}\log(n)\cr
    O(G(N)) &= O(k + N^{2/3} + \sqrt{N}\log(\sqrt{N}))\cr
    &= O(N^{2/3})
\end{aligned}

## Code

Here is the code, it's not so fast due to `mod` operations.

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define N 10000000
#define MOD 998244353

int phi[N];
int c_Phi[N];
unordered_map <ll, int> m_Phi;
void cphi(){
    phi[1] = 1;
    for(int i=2; i<N; i++){
        if(!phi[i]){
            phi[i] = i-1;
            for(ll j=2*i; j<N; j+=i){
                if(phi[j] == 0) phi[j] = j;
                phi[j] = phi[j]/i*(i-1);
            }
        }
    }
    c_Phi[1] = phi[1];
    for(int i=2; i<N; i++) c_Phi[i] = (c_Phi[i-1] + phi[i])%MOD;
}

int T(ll n){
    n %= MOD;
    ll ans = n*(n+1);
    ans %= MOD;
    ans *= 499122177;
    return ans%MOD;
}

ll Phi(ll n){
    if(n < N) return c_Phi[n];
    if(m_Phi.find(n) != m_Phi.end()) return m_Phi[n];
    ll ans = T(n);
    ll sqrt_n = floor(sqrt(n));
    for(int m=1; m < n/sqrt_n; m++){
        ans -= 1LL*(n/m - n/(m+1))*c_Phi[m];
        ans %= MOD;
        }
    for(int m=2; m<=sqrt_n; m++){
        ans -= Phi(n/m);
        ans %= MOD;
    }
    ans += MOD; ans %= MOD;
    m_Phi[n] = ans;
    return ans;
}

ll G(ll n){
    ll ans = 0;
    int sqrt_n = floor(sqrt(n));
    ans -= 1LL*T(sqrt_n)*Phi(sqrt_n);
    ans %= MOD;
    for(int i=1; i<=sqrt_n; i++){
        ans += Phi(n/i)*i;
        ans %= MOD;
    }

    for(int i=1; i<=sqrt_n; i++){
        ans += 1LL*phi[i]*T(n/i);
        ans %= MOD;
    }
    ans += MOD; ans %= MOD;
    return ans;
}

int main(){
    cphi();
    ll n; cin >> n;
    cout << G(n) << '\n';
    return 0;
}
```

## Resource:

I want to list them because I would like to go deeper into them and should review them further at my leisure.

- [griff's blog](https://gbroxey.github.io/blog/2023/04/30/mult-sum-1.html#powerful-numbers-trick)
- [Dirichlet Convolution](https://en.wikipedia.org/wiki/Dirichlet_convolution)
- [Beni's blog](https://mathproblems123.wordpress.com/2018/05/10/sum-of-the-euler-totient-function/)
- [codeforces blog](https://codeforces.com/blog/entry/54150)